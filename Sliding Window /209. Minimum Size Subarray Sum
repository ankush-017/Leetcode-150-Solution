class Solution {

    int upperBound(int[] pref,int req){

        int l = 0,h = pref.length-1;
        int idx = h+1;
        while(l<=h){
            int mid = l + (h-l)/2;
            if(pref[mid] > req){
                idx = mid;
                h = mid -1;
            }
            else{
                l = mid +1 ;
            }
        }

        return idx;
    }

    public int minSubArrayLen(int target, int[] nums) {
        
        // simply use the sliding window
        // do sum from the start => if sum greater or equla store legth => and the resize from left
        // TC: O(n) => SC: O(1)
        /*
        int n = nums.length;
        int i=0,j=0;
        int ans = Integer.MAX_VALUE;
        int sum = 0;
        while(j<n){
            sum += nums[j];
            while(sum >= target){
                ans = Math.min(ans,j-i+1);
                sum -= nums[i];
                i++;
            }
            j++;
        }

        return ans == Integer.MAX_VALUE ? 0 : ans;
        */

        // Follow-Up: try to do in => TC: O(nlogn) => SC: O(1);
        // using the prefix-sum + Binary-search

        int n = nums.length;
        int[] pref = new int[n + 1];
        for (int i = 0; i < n; i++) {
            pref[i + 1] = pref[i] + nums[i];
        }
        int ans = Integer.MAX_VALUE;
        for (int i = 1; i <= n; i++) {
            int req = pref[i] - target;
            if (req < 0) continue;

            int idx = upperBound(pref, req);
            ans = Math.min(ans, i - idx + 1);
        }

        return ans == Integer.MAX_VALUE ? 0 : ans;
    }
}
