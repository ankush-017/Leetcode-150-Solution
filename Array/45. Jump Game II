class Solution {

    // int n;
    // int[] dp;

    // int solve(int[] nums, int idx) {

    //     if (idx >= n - 1) return 0;
    //     if (dp[idx] != -1) return dp[idx];

    //     int maxJump = nums[idx];
    //     int minSteps = Integer.MAX_VALUE;

    //     for (int jump = 1; jump <= maxJump; jump++) {
    //         int next = idx + jump;
    //         int steps = solve(nums, next);
    //         if (steps != Integer.MAX_VALUE) minSteps = Math.min(minSteps, 1 + steps);
    //     }

    //     return dp[idx] = minSteps;
    // }

    public int jump(int[] nums) {
        
        // Approach 1: Using the 1D Dp => make two state => state: traverse each index
        // TC: O(n*jump) => worst TC: O(1e7)
        // SC: O(n)
        
        // Approach 2: using greedy => TC: O(n) => SC: O(1)
        
        int n = nums.length;
        int last = 0, maxiJump = 0, step = 0;
        for(int i=0;i<n-1;i++){
            maxiJump = Math.max(maxiJump,nums[i]+i);
            if(last == i){
                step++;
                last = maxiJump;
            }
        }

        return step;
    }
}
